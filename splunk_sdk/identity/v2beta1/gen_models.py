# Copyright Â© 2019 Splunk, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"): you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
# [http://www.apache.org/licenses/LICENSE-2.0]
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

############# This file is auto-generated.  Do not edit! #############

"""
    SDC Service: Identity

    With the Splunk Cloud Identity Service, you can authenticate and authorize Splunk API users.

    OpenAPI spec version: v2beta1.10 (recommended default)
    Generated by: https://openapi-generator.tech
"""


from datetime import datetime
from typing import List, Dict
from splunk_sdk.common.sscmodel import SSCModel
from splunk_sdk.base_client import dictify, inflate
from enum import Enum



class AddGroupMemberBody(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "AddGroupMemberBody":
        instance = AddGroupMemberBody.__new__(AddGroupMemberBody)
        instance._attrs = model
        return instance

    def __init__(self, name: "str", **extra):
        """AddGroupMemberBody"""

        self._attrs = dict()
        if name is not None:
            self._attrs["name"] = name
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def name(self) -> "str":
        """ Gets the name of this AddGroupMemberBody.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this AddGroupMemberBody.


        :param name: The name of this AddGroupMemberBody.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class AddGroupRoleBody(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "AddGroupRoleBody":
        instance = AddGroupRoleBody.__new__(AddGroupRoleBody)
        instance._attrs = model
        return instance

    def __init__(self, name: "str", **extra):
        """AddGroupRoleBody"""

        self._attrs = dict()
        if name is not None:
            self._attrs["name"] = name
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def name(self) -> "str":
        """ Gets the name of this AddGroupRoleBody.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this AddGroupRoleBody.


        :param name: The name of this AddGroupRoleBody.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class AddMemberBody(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "AddMemberBody":
        instance = AddMemberBody.__new__(AddMemberBody)
        instance._attrs = model
        return instance

    def __init__(self, name: "str", **extra):
        """AddMemberBody"""

        self._attrs = dict()
        if name is not None:
            self._attrs["name"] = name
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def name(self) -> "str":
        """ Gets the name of this AddMemberBody.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this AddMemberBody.


        :param name: The name of this AddMemberBody.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class AddRolePermissionBody(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "AddRolePermissionBody":
        instance = AddRolePermissionBody.__new__(AddRolePermissionBody)
        instance._attrs = model
        return instance

    def __init__(self, **extra):
        """AddRolePermissionBody"""

        self._attrs = dict()
        for k, v in extra.items():
            self._attrs[k] = v

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class CreateGroupBody(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "CreateGroupBody":
        instance = CreateGroupBody.__new__(CreateGroupBody)
        instance._attrs = model
        return instance

    def __init__(self, name: "str", **extra):
        """CreateGroupBody"""

        self._attrs = dict()
        if name is not None:
            self._attrs["name"] = name
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def name(self) -> "str":
        """ Gets the name of this CreateGroupBody.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this CreateGroupBody.


        :param name: The name of this CreateGroupBody.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class CreateRoleBody(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "CreateRoleBody":
        instance = CreateRoleBody.__new__(CreateRoleBody)
        instance._attrs = model
        return instance

    def __init__(self, name: "str", **extra):
        """CreateRoleBody"""

        self._attrs = dict()
        if name is not None:
            self._attrs["name"] = name
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def name(self) -> "str":
        """ Gets the name of this CreateRoleBody.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this CreateRoleBody.


        :param name: The name of this CreateRoleBody.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class Group(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "Group":
        instance = Group.__new__(Group)
        instance._attrs = model
        return instance

    def __init__(self, created_at: "datetime", created_by: "str", member_count: "int", name: "str", role_count: "int", tenant: "str", **extra):
        """Group"""

        self._attrs = dict()
        if created_at is not None:
            self._attrs["createdAt"] = created_at
        if created_by is not None:
            self._attrs["createdBy"] = created_by
        if member_count is not None:
            self._attrs["memberCount"] = member_count
        if name is not None:
            self._attrs["name"] = name
        if role_count is not None:
            self._attrs["roleCount"] = role_count
        if tenant is not None:
            self._attrs["tenant"] = tenant
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def created_at(self) -> "datetime":
        """ Gets the created_at of this Group.
        """
        return self._attrs.get("createdAt")

    @created_at.setter
    def created_at(self, created_at: "datetime"):
        """Sets the created_at of this Group.


        :param created_at: The created_at of this Group.
        :type: datetime
        """
        if created_at is None:
            raise ValueError("Invalid value for `created_at`, must not be `None`")
        self._attrs["createdAt"] = created_at

    @property
    def created_by(self) -> "str":
        """ Gets the created_by of this Group.
        """
        return self._attrs.get("createdBy")

    @created_by.setter
    def created_by(self, created_by: "str"):
        """Sets the created_by of this Group.


        :param created_by: The created_by of this Group.
        :type: str
        """
        if created_by is None:
            raise ValueError("Invalid value for `created_by`, must not be `None`")
        self._attrs["createdBy"] = created_by

    @property
    def member_count(self) -> "int":
        """ Gets the member_count of this Group.
        """
        return self._attrs.get("memberCount")

    @member_count.setter
    def member_count(self, member_count: "int"):
        """Sets the member_count of this Group.


        :param member_count: The member_count of this Group.
        :type: int
        """
        if member_count is None:
            raise ValueError("Invalid value for `member_count`, must not be `None`")
        self._attrs["memberCount"] = member_count

    @property
    def name(self) -> "str":
        """ Gets the name of this Group.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this Group.


        :param name: The name of this Group.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    @property
    def role_count(self) -> "int":
        """ Gets the role_count of this Group.
        """
        return self._attrs.get("roleCount")

    @role_count.setter
    def role_count(self, role_count: "int"):
        """Sets the role_count of this Group.


        :param role_count: The role_count of this Group.
        :type: int
        """
        if role_count is None:
            raise ValueError("Invalid value for `role_count`, must not be `None`")
        self._attrs["roleCount"] = role_count

    @property
    def tenant(self) -> "str":
        """ Gets the tenant of this Group.
        """
        return self._attrs.get("tenant")

    @tenant.setter
    def tenant(self, tenant: "str"):
        """Sets the tenant of this Group.


        :param tenant: The tenant of this Group.
        :type: str
        """
        if tenant is None:
            raise ValueError("Invalid value for `tenant`, must not be `None`")
        self._attrs["tenant"] = tenant

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class GroupMember(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "GroupMember":
        instance = GroupMember.__new__(GroupMember)
        instance._attrs = model
        return instance

    def __init__(self, added_at: "datetime", added_by: "str", group: "str", principal: "str", tenant: "str", **extra):
        """GroupMember"""

        self._attrs = dict()
        if added_at is not None:
            self._attrs["addedAt"] = added_at
        if added_by is not None:
            self._attrs["addedBy"] = added_by
        if group is not None:
            self._attrs["group"] = group
        if principal is not None:
            self._attrs["principal"] = principal
        if tenant is not None:
            self._attrs["tenant"] = tenant
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def added_at(self) -> "datetime":
        """ Gets the added_at of this GroupMember.
        """
        return self._attrs.get("addedAt")

    @added_at.setter
    def added_at(self, added_at: "datetime"):
        """Sets the added_at of this GroupMember.


        :param added_at: The added_at of this GroupMember.
        :type: datetime
        """
        if added_at is None:
            raise ValueError("Invalid value for `added_at`, must not be `None`")
        self._attrs["addedAt"] = added_at

    @property
    def added_by(self) -> "str":
        """ Gets the added_by of this GroupMember.
        """
        return self._attrs.get("addedBy")

    @added_by.setter
    def added_by(self, added_by: "str"):
        """Sets the added_by of this GroupMember.


        :param added_by: The added_by of this GroupMember.
        :type: str
        """
        if added_by is None:
            raise ValueError("Invalid value for `added_by`, must not be `None`")
        self._attrs["addedBy"] = added_by

    @property
    def group(self) -> "str":
        """ Gets the group of this GroupMember.
        """
        return self._attrs.get("group")

    @group.setter
    def group(self, group: "str"):
        """Sets the group of this GroupMember.


        :param group: The group of this GroupMember.
        :type: str
        """
        if group is None:
            raise ValueError("Invalid value for `group`, must not be `None`")
        self._attrs["group"] = group

    @property
    def principal(self) -> "str":
        """ Gets the principal of this GroupMember.
        """
        return self._attrs.get("principal")

    @principal.setter
    def principal(self, principal: "str"):
        """Sets the principal of this GroupMember.


        :param principal: The principal of this GroupMember.
        :type: str
        """
        if principal is None:
            raise ValueError("Invalid value for `principal`, must not be `None`")
        self._attrs["principal"] = principal

    @property
    def tenant(self) -> "str":
        """ Gets the tenant of this GroupMember.
        """
        return self._attrs.get("tenant")

    @tenant.setter
    def tenant(self, tenant: "str"):
        """Sets the tenant of this GroupMember.


        :param tenant: The tenant of this GroupMember.
        :type: str
        """
        if tenant is None:
            raise ValueError("Invalid value for `tenant`, must not be `None`")
        self._attrs["tenant"] = tenant

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class GroupRole(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "GroupRole":
        instance = GroupRole.__new__(GroupRole)
        instance._attrs = model
        return instance

    def __init__(self, added_at: "datetime", added_by: "str", group: "str", role: "str", tenant: "str", **extra):
        """GroupRole"""

        self._attrs = dict()
        if added_at is not None:
            self._attrs["addedAt"] = added_at
        if added_by is not None:
            self._attrs["addedBy"] = added_by
        if group is not None:
            self._attrs["group"] = group
        if role is not None:
            self._attrs["role"] = role
        if tenant is not None:
            self._attrs["tenant"] = tenant
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def added_at(self) -> "datetime":
        """ Gets the added_at of this GroupRole.
        """
        return self._attrs.get("addedAt")

    @added_at.setter
    def added_at(self, added_at: "datetime"):
        """Sets the added_at of this GroupRole.


        :param added_at: The added_at of this GroupRole.
        :type: datetime
        """
        if added_at is None:
            raise ValueError("Invalid value for `added_at`, must not be `None`")
        self._attrs["addedAt"] = added_at

    @property
    def added_by(self) -> "str":
        """ Gets the added_by of this GroupRole.
        """
        return self._attrs.get("addedBy")

    @added_by.setter
    def added_by(self, added_by: "str"):
        """Sets the added_by of this GroupRole.


        :param added_by: The added_by of this GroupRole.
        :type: str
        """
        if added_by is None:
            raise ValueError("Invalid value for `added_by`, must not be `None`")
        self._attrs["addedBy"] = added_by

    @property
    def group(self) -> "str":
        """ Gets the group of this GroupRole.
        """
        return self._attrs.get("group")

    @group.setter
    def group(self, group: "str"):
        """Sets the group of this GroupRole.


        :param group: The group of this GroupRole.
        :type: str
        """
        if group is None:
            raise ValueError("Invalid value for `group`, must not be `None`")
        self._attrs["group"] = group

    @property
    def role(self) -> "str":
        """ Gets the role of this GroupRole.
        """
        return self._attrs.get("role")

    @role.setter
    def role(self, role: "str"):
        """Sets the role of this GroupRole.


        :param role: The role of this GroupRole.
        :type: str
        """
        if role is None:
            raise ValueError("Invalid value for `role`, must not be `None`")
        self._attrs["role"] = role

    @property
    def tenant(self) -> "str":
        """ Gets the tenant of this GroupRole.
        """
        return self._attrs.get("tenant")

    @tenant.setter
    def tenant(self, tenant: "str"):
        """Sets the tenant of this GroupRole.


        :param tenant: The tenant of this GroupRole.
        :type: str
        """
        if tenant is None:
            raise ValueError("Invalid value for `tenant`, must not be `None`")
        self._attrs["tenant"] = tenant

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class PrincipalProfile(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "PrincipalProfile":
        instance = PrincipalProfile.__new__(PrincipalProfile)
        instance._attrs = model
        return instance

    def __init__(self, email: "str" = None, full_name: "str" = None, **extra):
        """PrincipalProfile"""

        self._attrs = dict()
        if email is not None:
            self._attrs["email"] = email
        if full_name is not None:
            self._attrs["fullName"] = full_name
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def email(self) -> "str":
        """ Gets the email of this PrincipalProfile.
        """
        return self._attrs.get("email")

    @email.setter
    def email(self, email: "str"):
        """Sets the email of this PrincipalProfile.


        :param email: The email of this PrincipalProfile.
        :type: str
        """
        self._attrs["email"] = email

    @property
    def full_name(self) -> "str":
        """ Gets the full_name of this PrincipalProfile.
        """
        return self._attrs.get("fullName")

    @full_name.setter
    def full_name(self, full_name: "str"):
        """Sets the full_name of this PrincipalProfile.


        :param full_name: The full_name of this PrincipalProfile.
        :type: str
        """
        self._attrs["fullName"] = full_name

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class Member(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "Member":
        instance = Member.__new__(Member)
        instance._attrs = model
        return instance

    def __init__(self, added_at: "datetime", added_by: "str", group_count: "int", name: "str", tenant: "str", profile: "PrincipalProfile" = None, **extra):
        """Member"""

        self._attrs = dict()
        if added_at is not None:
            self._attrs["addedAt"] = added_at
        if added_by is not None:
            self._attrs["addedBy"] = added_by
        if group_count is not None:
            self._attrs["groupCount"] = group_count
        if name is not None:
            self._attrs["name"] = name
        if tenant is not None:
            self._attrs["tenant"] = tenant
        if profile is not None:
            self._attrs["profile"] = profile.to_dict()
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def added_at(self) -> "datetime":
        """ Gets the added_at of this Member.
        When the principal was added to the tenant.
        """
        return self._attrs.get("addedAt")

    @added_at.setter
    def added_at(self, added_at: "datetime"):
        """Sets the added_at of this Member.

        When the principal was added to the tenant.

        :param added_at: The added_at of this Member.
        :type: datetime
        """
        if added_at is None:
            raise ValueError("Invalid value for `added_at`, must not be `None`")
        self._attrs["addedAt"] = added_at

    @property
    def added_by(self) -> "str":
        """ Gets the added_by of this Member.
        """
        return self._attrs.get("addedBy")

    @added_by.setter
    def added_by(self, added_by: "str"):
        """Sets the added_by of this Member.


        :param added_by: The added_by of this Member.
        :type: str
        """
        if added_by is None:
            raise ValueError("Invalid value for `added_by`, must not be `None`")
        self._attrs["addedBy"] = added_by

    @property
    def group_count(self) -> "int":
        """ Gets the group_count of this Member.
        """
        return self._attrs.get("groupCount")

    @group_count.setter
    def group_count(self, group_count: "int"):
        """Sets the group_count of this Member.


        :param group_count: The group_count of this Member.
        :type: int
        """
        if group_count is None:
            raise ValueError("Invalid value for `group_count`, must not be `None`")
        self._attrs["groupCount"] = group_count

    @property
    def name(self) -> "str":
        """ Gets the name of this Member.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this Member.


        :param name: The name of this Member.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    @property
    def tenant(self) -> "str":
        """ Gets the tenant of this Member.
        """
        return self._attrs.get("tenant")

    @tenant.setter
    def tenant(self, tenant: "str"):
        """Sets the tenant of this Member.


        :param tenant: The tenant of this Member.
        :type: str
        """
        if tenant is None:
            raise ValueError("Invalid value for `tenant`, must not be `None`")
        self._attrs["tenant"] = tenant

    @property
    def profile(self) -> "PrincipalProfile":
        """ Gets the profile of this Member.
        """
        return PrincipalProfile._from_dict(self._attrs["profile"])

    @profile.setter
    def profile(self, profile: "PrincipalProfile"):
        """Sets the profile of this Member.


        :param profile: The profile of this Member.
        :type: PrincipalProfile
        """
        self._attrs["profile"] = profile.to_dict()

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class PrincipalKind(str, Enum):
    USER = "user"
    SERVICE_ACCOUNT = "service_account"

    @staticmethod
    def from_value(value: str):
        if value == "user":
            return PrincipalKind.USER
        if value == "service_account":
            return PrincipalKind.SERVICE_ACCOUNT


class Principal(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "Principal":
        instance = Principal.__new__(Principal)
        instance._attrs = model
        return instance

    def __init__(self, created_at: "datetime", created_by: "str", kind: "PrincipalKind", name: "str", tenants: "List[str]", updated_at: "datetime", updated_by: "str", profile: "PrincipalProfile" = None, **extra):
        """Principal"""

        self._attrs = dict()
        if created_at is not None:
            self._attrs["createdAt"] = created_at
        if created_by is not None:
            self._attrs["createdBy"] = created_by
        if kind is not None:
            self._attrs["kind"] = kind
        if name is not None:
            self._attrs["name"] = name
        if tenants is not None:
            self._attrs["tenants"] = tenants
        if updated_at is not None:
            self._attrs["updatedAt"] = updated_at
        if updated_by is not None:
            self._attrs["updatedBy"] = updated_by
        if profile is not None:
            self._attrs["profile"] = profile.to_dict()
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def created_at(self) -> "datetime":
        """ Gets the created_at of this Principal.
        """
        return self._attrs.get("createdAt")

    @created_at.setter
    def created_at(self, created_at: "datetime"):
        """Sets the created_at of this Principal.


        :param created_at: The created_at of this Principal.
        :type: datetime
        """
        if created_at is None:
            raise ValueError("Invalid value for `created_at`, must not be `None`")
        self._attrs["createdAt"] = created_at

    @property
    def created_by(self) -> "str":
        """ Gets the created_by of this Principal.
        """
        return self._attrs.get("createdBy")

    @created_by.setter
    def created_by(self, created_by: "str"):
        """Sets the created_by of this Principal.


        :param created_by: The created_by of this Principal.
        :type: str
        """
        if created_by is None:
            raise ValueError("Invalid value for `created_by`, must not be `None`")
        self._attrs["createdBy"] = created_by

    @property
    def kind(self) -> "PrincipalKind":
        """ Gets the kind of this Principal.
        """
        return PrincipalKind.from_value(self._attrs.get("kind"))

    @kind.setter
    def kind(self, kind: "PrincipalKind"):
        """Sets the kind of this Principal.


        :param kind: The kind of this Principal.
        :type: PrincipalKind
        """
        if kind is None:
            raise ValueError("Invalid value for `kind`, must not be `None`")
        if isinstance(kind, Enum):
            self._attrs["kind"] = kind.value
        else:
            self._attrs["kind"] = kind  # If you supply a string, we presume you know the service will take it.

    @property
    def name(self) -> "str":
        """ Gets the name of this Principal.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this Principal.


        :param name: The name of this Principal.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    @property
    def tenants(self) -> "List[str]":
        """ Gets the tenants of this Principal.
        """
        return self._attrs.get("tenants")

    @tenants.setter
    def tenants(self, tenants: "List[str]"):
        """Sets the tenants of this Principal.


        :param tenants: The tenants of this Principal.
        :type: List[str]
        """
        if tenants is None:
            raise ValueError("Invalid value for `tenants`, must not be `None`")
        self._attrs["tenants"] = tenants

    @property
    def updated_at(self) -> "datetime":
        """ Gets the updated_at of this Principal.
        """
        return self._attrs.get("updatedAt")

    @updated_at.setter
    def updated_at(self, updated_at: "datetime"):
        """Sets the updated_at of this Principal.


        :param updated_at: The updated_at of this Principal.
        :type: datetime
        """
        if updated_at is None:
            raise ValueError("Invalid value for `updated_at`, must not be `None`")
        self._attrs["updatedAt"] = updated_at

    @property
    def updated_by(self) -> "str":
        """ Gets the updated_by of this Principal.
        """
        return self._attrs.get("updatedBy")

    @updated_by.setter
    def updated_by(self, updated_by: "str"):
        """Sets the updated_by of this Principal.


        :param updated_by: The updated_by of this Principal.
        :type: str
        """
        if updated_by is None:
            raise ValueError("Invalid value for `updated_by`, must not be `None`")
        self._attrs["updatedBy"] = updated_by

    @property
    def profile(self) -> "PrincipalProfile":
        """ Gets the profile of this Principal.
        """
        return PrincipalProfile._from_dict(self._attrs["profile"])

    @profile.setter
    def profile(self, profile: "PrincipalProfile"):
        """Sets the profile of this Principal.


        :param profile: The profile of this Principal.
        :type: PrincipalProfile
        """
        self._attrs["profile"] = profile.to_dict()

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class Role(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "Role":
        instance = Role.__new__(Role)
        instance._attrs = model
        return instance

    def __init__(self, created_at: "datetime", created_by: "str", name: "str", tenant: "str", **extra):
        """Role"""

        self._attrs = dict()
        if created_at is not None:
            self._attrs["createdAt"] = created_at
        if created_by is not None:
            self._attrs["createdBy"] = created_by
        if name is not None:
            self._attrs["name"] = name
        if tenant is not None:
            self._attrs["tenant"] = tenant
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def created_at(self) -> "datetime":
        """ Gets the created_at of this Role.
        """
        return self._attrs.get("createdAt")

    @created_at.setter
    def created_at(self, created_at: "datetime"):
        """Sets the created_at of this Role.


        :param created_at: The created_at of this Role.
        :type: datetime
        """
        if created_at is None:
            raise ValueError("Invalid value for `created_at`, must not be `None`")
        self._attrs["createdAt"] = created_at

    @property
    def created_by(self) -> "str":
        """ Gets the created_by of this Role.
        """
        return self._attrs.get("createdBy")

    @created_by.setter
    def created_by(self, created_by: "str"):
        """Sets the created_by of this Role.


        :param created_by: The created_by of this Role.
        :type: str
        """
        if created_by is None:
            raise ValueError("Invalid value for `created_by`, must not be `None`")
        self._attrs["createdBy"] = created_by

    @property
    def name(self) -> "str":
        """ Gets the name of this Role.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this Role.


        :param name: The name of this Role.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    @property
    def tenant(self) -> "str":
        """ Gets the tenant of this Role.
        """
        return self._attrs.get("tenant")

    @tenant.setter
    def tenant(self, tenant: "str"):
        """Sets the tenant of this Role.


        :param tenant: The tenant of this Role.
        :type: str
        """
        if tenant is None:
            raise ValueError("Invalid value for `tenant`, must not be `None`")
        self._attrs["tenant"] = tenant

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class RolePermission(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "RolePermission":
        instance = RolePermission.__new__(RolePermission)
        instance._attrs = model
        return instance

    def __init__(self, added_at: "datetime", added_by: "str", permission: "str", role: "str", tenant: "str", **extra):
        """RolePermission"""

        self._attrs = dict()
        if added_at is not None:
            self._attrs["addedAt"] = added_at
        if added_by is not None:
            self._attrs["addedBy"] = added_by
        if permission is not None:
            self._attrs["permission"] = permission
        if role is not None:
            self._attrs["role"] = role
        if tenant is not None:
            self._attrs["tenant"] = tenant
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def added_at(self) -> "datetime":
        """ Gets the added_at of this RolePermission.
        """
        return self._attrs.get("addedAt")

    @added_at.setter
    def added_at(self, added_at: "datetime"):
        """Sets the added_at of this RolePermission.


        :param added_at: The added_at of this RolePermission.
        :type: datetime
        """
        if added_at is None:
            raise ValueError("Invalid value for `added_at`, must not be `None`")
        self._attrs["addedAt"] = added_at

    @property
    def added_by(self) -> "str":
        """ Gets the added_by of this RolePermission.
        """
        return self._attrs.get("addedBy")

    @added_by.setter
    def added_by(self, added_by: "str"):
        """Sets the added_by of this RolePermission.


        :param added_by: The added_by of this RolePermission.
        :type: str
        """
        if added_by is None:
            raise ValueError("Invalid value for `added_by`, must not be `None`")
        self._attrs["addedBy"] = added_by

    @property
    def permission(self) -> "str":
        """ Gets the permission of this RolePermission.
        """
        return self._attrs.get("permission")

    @permission.setter
    def permission(self, permission: "str"):
        """Sets the permission of this RolePermission.


        :param permission: The permission of this RolePermission.
        :type: str
        """
        if permission is None:
            raise ValueError("Invalid value for `permission`, must not be `None`")
        self._attrs["permission"] = permission

    @property
    def role(self) -> "str":
        """ Gets the role of this RolePermission.
        """
        return self._attrs.get("role")

    @role.setter
    def role(self, role: "str"):
        """Sets the role of this RolePermission.


        :param role: The role of this RolePermission.
        :type: str
        """
        if role is None:
            raise ValueError("Invalid value for `role`, must not be `None`")
        self._attrs["role"] = role

    @property
    def tenant(self) -> "str":
        """ Gets the tenant of this RolePermission.
        """
        return self._attrs.get("tenant")

    @tenant.setter
    def tenant(self, tenant: "str"):
        """Sets the tenant of this RolePermission.


        :param tenant: The tenant of this RolePermission.
        :type: str
        """
        if tenant is None:
            raise ValueError("Invalid value for `tenant`, must not be `None`")
        self._attrs["tenant"] = tenant

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class TenantStatus(str, Enum):
    PROVISIONING = "provisioning"
    FAILED = "failed"
    READY = "ready"
    DELETING = "deleting"
    DELETED = "deleted"
    SUSPENDED = "suspended"

    @staticmethod
    def from_value(value: str):
        if value == "provisioning":
            return TenantStatus.PROVISIONING
        if value == "failed":
            return TenantStatus.FAILED
        if value == "ready":
            return TenantStatus.READY
        if value == "deleting":
            return TenantStatus.DELETING
        if value == "deleted":
            return TenantStatus.DELETED
        if value == "suspended":
            return TenantStatus.SUSPENDED


class Tenant(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "Tenant":
        instance = Tenant.__new__(Tenant)
        instance._attrs = model
        return instance

    def __init__(self, created_at: "datetime", created_by: "str", name: "str", status: "TenantStatus", **extra):
        """Tenant"""

        self._attrs = dict()
        if created_at is not None:
            self._attrs["createdAt"] = created_at
        if created_by is not None:
            self._attrs["createdBy"] = created_by
        if name is not None:
            self._attrs["name"] = name
        if status is not None:
            self._attrs["status"] = status
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def created_at(self) -> "datetime":
        """ Gets the created_at of this Tenant.
        """
        return self._attrs.get("createdAt")

    @created_at.setter
    def created_at(self, created_at: "datetime"):
        """Sets the created_at of this Tenant.


        :param created_at: The created_at of this Tenant.
        :type: datetime
        """
        if created_at is None:
            raise ValueError("Invalid value for `created_at`, must not be `None`")
        self._attrs["createdAt"] = created_at

    @property
    def created_by(self) -> "str":
        """ Gets the created_by of this Tenant.
        """
        return self._attrs.get("createdBy")

    @created_by.setter
    def created_by(self, created_by: "str"):
        """Sets the created_by of this Tenant.


        :param created_by: The created_by of this Tenant.
        :type: str
        """
        if created_by is None:
            raise ValueError("Invalid value for `created_by`, must not be `None`")
        self._attrs["createdBy"] = created_by

    @property
    def name(self) -> "str":
        """ Gets the name of this Tenant.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this Tenant.


        :param name: The name of this Tenant.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    @property
    def status(self) -> "TenantStatus":
        """ Gets the status of this Tenant.
        """
        return TenantStatus.from_value(self._attrs.get("status"))

    @status.setter
    def status(self, status: "TenantStatus"):
        """Sets the status of this Tenant.


        :param status: The status of this Tenant.
        :type: TenantStatus
        """
        if status is None:
            raise ValueError("Invalid value for `status`, must not be `None`")
        if isinstance(status, Enum):
            self._attrs["status"] = status.value
        else:
            self._attrs["status"] = status  # If you supply a string, we presume you know the service will take it.

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}


class ValidateInfo(SSCModel):

    @staticmethod
    def _from_dict(model: dict) -> "ValidateInfo":
        instance = ValidateInfo.__new__(ValidateInfo)
        instance._attrs = model
        return instance

    def __init__(self, client_id: "str", name: "str", principal: "Principal" = None, tenant: "Tenant" = None, **extra):
        """ValidateInfo"""

        self._attrs = dict()
        if client_id is not None:
            self._attrs["clientId"] = client_id
        if name is not None:
            self._attrs["name"] = name
        if principal is not None:
            self._attrs["principal"] = principal.to_dict()
        if tenant is not None:
            self._attrs["tenant"] = tenant.to_dict()
        for k, v in extra.items():
            self._attrs[k] = v

    @property
    def client_id(self) -> "str":
        """ Gets the client_id of this ValidateInfo.
        """
        return self._attrs.get("clientId")

    @client_id.setter
    def client_id(self, client_id: "str"):
        """Sets the client_id of this ValidateInfo.


        :param client_id: The client_id of this ValidateInfo.
        :type: str
        """
        if client_id is None:
            raise ValueError("Invalid value for `client_id`, must not be `None`")
        self._attrs["clientId"] = client_id

    @property
    def name(self) -> "str":
        """ Gets the name of this ValidateInfo.
        """
        return self._attrs.get("name")

    @name.setter
    def name(self, name: "str"):
        """Sets the name of this ValidateInfo.


        :param name: The name of this ValidateInfo.
        :type: str
        """
        if name is None:
            raise ValueError("Invalid value for `name`, must not be `None`")
        self._attrs["name"] = name

    @property
    def principal(self) -> "Principal":
        """ Gets the principal of this ValidateInfo.
        """
        return Principal._from_dict(self._attrs["principal"])

    @principal.setter
    def principal(self, principal: "Principal"):
        """Sets the principal of this ValidateInfo.


        :param principal: The principal of this ValidateInfo.
        :type: Principal
        """
        self._attrs["principal"] = principal.to_dict()

    @property
    def tenant(self) -> "Tenant":
        """ Gets the tenant of this ValidateInfo.
        """
        return Tenant._from_dict(self._attrs["tenant"])

    @tenant.setter
    def tenant(self, tenant: "Tenant"):
        """Sets the tenant of this ValidateInfo.


        :param tenant: The tenant of this ValidateInfo.
        :type: Tenant
        """
        self._attrs["tenant"] = tenant.to_dict()

    def to_dict(self):
        return {k: v for (k, v) in self._attrs.items() if v is not None}
